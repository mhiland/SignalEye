<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFi Spectrum</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .button-bar {
            text-align: center;
            margin-bottom: 20px;
        }
        .button-bar a {
            display: inline-block;
            margin-right: 10px;
        }
        pre {
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="button-bar">
        <a href="{{ url_for('index') }}">Home</a>
        <a href="{{ url_for('logs') }}">View Logs</a>
        <a href="{{ url_for('spectrum') }}">View Spectrum</a>
        <a href="{{ url_for('download') }}">Download JSON</a>
    </div>

    <h1>WiFi Spectrum Analysis (Last 24 Hours)</h1>
    <div class="button-bar">
        <a href="#2.4ghzChart">2.4GHz Spectrum</a>
        <a href="#5ghzChart">5GHz Spectrum</a>
    </div>

    <h2 id="2.4ghzChart">2.4GHz Band</h2>
    <canvas id="2.4ghzChartCanvas"></canvas>

    <h2 id="5ghzChart">5GHz Band</h2>
    <canvas id="5ghzChartCanvas"></canvas>

    <script>
        const spectrumData = JSON.parse('{{ spectrum_data|safe }}');

        function calculatePointSizes(data) {
            const pointSizeMap = {};

            data.forEach(d => {
                const key = `${d.channel}_${d.signal_level}`;
                if (!pointSizeMap[key]) {
                    pointSizeMap[key] = 0;
                }
                pointSizeMap[key]++;
            });

            return pointSizeMap;
        }

        function formatScatterData(data, allChannels) {
            const datasets = [];
            const pointSizeMap = calculatePointSizes(data);

            const groupedData = {};

            data.forEach(d => {
                const channel = d.channel;
                if (!groupedData[channel]) {
                    groupedData[channel] = [];
                }
                groupedData[channel].push(d);
            });

            Object.keys(groupedData).forEach(channel => {
                groupedData[channel].forEach(d => {
                    const essid = d.essid || "Hidden SSID";
                    const bgColor = `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.2)`;
                    const borderColor = `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 1)`;

                    const key = `${channel}_${d.signal_level}`;
                    const pointSize = pointSizeMap[key] * 5;

                    datasets.push({
                        label: `${essid} (Channel ${channel})`,
                        data: [{
                            x: channel,
                            y: d.signal_level,
                            r: pointSize
                        }],
                        backgroundColor: bgColor,
                        borderColor: borderColor,
                        borderWidth: 1,
                        hoverBackgroundColor: bgColor,
                        hoverBorderColor: borderColor,
                        hoverBorderWidth: 2
                    });
                });
            });

            return {
                labels: allChannels.map(channel => `Channel ${channel}`),
                datasets: datasets
            };
        }


        const ctx24 = document.getElementById('2.4ghzChartCanvas').getContext('2d');
        const ctx5 = document.getElementById('5ghzChartCanvas').getContext('2d');

        const allChannels24GHz = [...Array(14).keys()].map(i => i + 1); // Channels 1 to 14
        const allChannels5GHz = [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165];

        const chart24 = new Chart(ctx24, {
            type: 'bubble',
            data: formatScatterData(spectrumData['2.4GHz'], allChannels24GHz),
            options: {
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'Channel'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Signal Level'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                let channel = tooltipItems[0].raw.x;
                                return `Channel ${channel}`;
                            },
                            label: function(tooltipItem) {
                                let datasetLabel = tooltipItem.dataset.label || '';
                                let data = tooltipItem.raw;
                                return `${datasetLabel}: (${data.x}, ${data.y}, ${data.r})`;
                            }
                        }
                    }
                }
            }
        });

        const chart5 = new Chart(ctx5, {
            type: 'bubble',
            data: formatScatterData(spectrumData['5GHz'], allChannels5GHz),
            options: {
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'Channel'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Signal Level'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                let channel = tooltipItems[0].raw.x;
                                return `Channel ${channel}`;
                            },
                            label: function(tooltipItem) {
                                let datasetLabel = tooltipItem.dataset.label || '';
                                let data = tooltipItem.raw;
                                return `${datasetLabel}: (${data.x}, ${data.y}, ${data.r})`;
                            }
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>
